// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sections.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SectionClickedEvent _$SectionClickedEventFromJson(Map<String, dynamic> json) {
  return _SectionClickedEvent.fromJson(json);
}

/// @nodoc
mixin _$SectionClickedEvent {
  String get sectionId => throw _privateConstructorUsedError;
  String? get sectionName => throw _privateConstructorUsedError;
  int get sectionPosition => throw _privateConstructorUsedError;
  String get sectionType => throw _privateConstructorUsedError;
  String? get elementName => throw _privateConstructorUsedError;
  int get elementPosition => throw _privateConstructorUsedError;
  String get elementType => throw _privateConstructorUsedError;
  String get elementId => throw _privateConstructorUsedError;
  String? get pageCode => throw _privateConstructorUsedError;
  Map<String, dynamic>? get meta => throw _privateConstructorUsedError;

  /// Serializes this SectionClickedEvent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SectionClickedEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SectionClickedEventCopyWith<SectionClickedEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SectionClickedEventCopyWith<$Res> {
  factory $SectionClickedEventCopyWith(
          SectionClickedEvent value, $Res Function(SectionClickedEvent) then) =
      _$SectionClickedEventCopyWithImpl<$Res, SectionClickedEvent>;
  @useResult
  $Res call(
      {String sectionId,
      String? sectionName,
      int sectionPosition,
      String sectionType,
      String? elementName,
      int elementPosition,
      String elementType,
      String elementId,
      String? pageCode,
      Map<String, dynamic>? meta});
}

/// @nodoc
class _$SectionClickedEventCopyWithImpl<$Res, $Val extends SectionClickedEvent>
    implements $SectionClickedEventCopyWith<$Res> {
  _$SectionClickedEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SectionClickedEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sectionId = null,
    Object? sectionName = freezed,
    Object? sectionPosition = null,
    Object? sectionType = null,
    Object? elementName = freezed,
    Object? elementPosition = null,
    Object? elementType = null,
    Object? elementId = null,
    Object? pageCode = freezed,
    Object? meta = freezed,
  }) {
    return _then(_value.copyWith(
      sectionId: null == sectionId
          ? _value.sectionId
          : sectionId // ignore: cast_nullable_to_non_nullable
              as String,
      sectionName: freezed == sectionName
          ? _value.sectionName
          : sectionName // ignore: cast_nullable_to_non_nullable
              as String?,
      sectionPosition: null == sectionPosition
          ? _value.sectionPosition
          : sectionPosition // ignore: cast_nullable_to_non_nullable
              as int,
      sectionType: null == sectionType
          ? _value.sectionType
          : sectionType // ignore: cast_nullable_to_non_nullable
              as String,
      elementName: freezed == elementName
          ? _value.elementName
          : elementName // ignore: cast_nullable_to_non_nullable
              as String?,
      elementPosition: null == elementPosition
          ? _value.elementPosition
          : elementPosition // ignore: cast_nullable_to_non_nullable
              as int,
      elementType: null == elementType
          ? _value.elementType
          : elementType // ignore: cast_nullable_to_non_nullable
              as String,
      elementId: null == elementId
          ? _value.elementId
          : elementId // ignore: cast_nullable_to_non_nullable
              as String,
      pageCode: freezed == pageCode
          ? _value.pageCode
          : pageCode // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SectionClickedEventImplCopyWith<$Res>
    implements $SectionClickedEventCopyWith<$Res> {
  factory _$$SectionClickedEventImplCopyWith(_$SectionClickedEventImpl value,
          $Res Function(_$SectionClickedEventImpl) then) =
      __$$SectionClickedEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String sectionId,
      String? sectionName,
      int sectionPosition,
      String sectionType,
      String? elementName,
      int elementPosition,
      String elementType,
      String elementId,
      String? pageCode,
      Map<String, dynamic>? meta});
}

/// @nodoc
class __$$SectionClickedEventImplCopyWithImpl<$Res>
    extends _$SectionClickedEventCopyWithImpl<$Res, _$SectionClickedEventImpl>
    implements _$$SectionClickedEventImplCopyWith<$Res> {
  __$$SectionClickedEventImplCopyWithImpl(_$SectionClickedEventImpl _value,
      $Res Function(_$SectionClickedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of SectionClickedEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sectionId = null,
    Object? sectionName = freezed,
    Object? sectionPosition = null,
    Object? sectionType = null,
    Object? elementName = freezed,
    Object? elementPosition = null,
    Object? elementType = null,
    Object? elementId = null,
    Object? pageCode = freezed,
    Object? meta = freezed,
  }) {
    return _then(_$SectionClickedEventImpl(
      sectionId: null == sectionId
          ? _value.sectionId
          : sectionId // ignore: cast_nullable_to_non_nullable
              as String,
      sectionName: freezed == sectionName
          ? _value.sectionName
          : sectionName // ignore: cast_nullable_to_non_nullable
              as String?,
      sectionPosition: null == sectionPosition
          ? _value.sectionPosition
          : sectionPosition // ignore: cast_nullable_to_non_nullable
              as int,
      sectionType: null == sectionType
          ? _value.sectionType
          : sectionType // ignore: cast_nullable_to_non_nullable
              as String,
      elementName: freezed == elementName
          ? _value.elementName
          : elementName // ignore: cast_nullable_to_non_nullable
              as String?,
      elementPosition: null == elementPosition
          ? _value.elementPosition
          : elementPosition // ignore: cast_nullable_to_non_nullable
              as int,
      elementType: null == elementType
          ? _value.elementType
          : elementType // ignore: cast_nullable_to_non_nullable
              as String,
      elementId: null == elementId
          ? _value.elementId
          : elementId // ignore: cast_nullable_to_non_nullable
              as String,
      pageCode: freezed == pageCode
          ? _value.pageCode
          : pageCode // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value._meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SectionClickedEventImpl implements _SectionClickedEvent {
  const _$SectionClickedEventImpl(
      {required this.sectionId,
      this.sectionName,
      required this.sectionPosition,
      required this.sectionType,
      this.elementName,
      required this.elementPosition,
      required this.elementType,
      required this.elementId,
      this.pageCode,
      final Map<String, dynamic>? meta})
      : _meta = meta;

  factory _$SectionClickedEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$SectionClickedEventImplFromJson(json);

  @override
  final String sectionId;
  @override
  final String? sectionName;
  @override
  final int sectionPosition;
  @override
  final String sectionType;
  @override
  final String? elementName;
  @override
  final int elementPosition;
  @override
  final String elementType;
  @override
  final String elementId;
  @override
  final String? pageCode;
  final Map<String, dynamic>? _meta;
  @override
  Map<String, dynamic>? get meta {
    final value = _meta;
    if (value == null) return null;
    if (_meta is EqualUnmodifiableMapView) return _meta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'SectionClickedEvent(sectionId: $sectionId, sectionName: $sectionName, sectionPosition: $sectionPosition, sectionType: $sectionType, elementName: $elementName, elementPosition: $elementPosition, elementType: $elementType, elementId: $elementId, pageCode: $pageCode, meta: $meta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SectionClickedEventImpl &&
            (identical(other.sectionId, sectionId) ||
                other.sectionId == sectionId) &&
            (identical(other.sectionName, sectionName) ||
                other.sectionName == sectionName) &&
            (identical(other.sectionPosition, sectionPosition) ||
                other.sectionPosition == sectionPosition) &&
            (identical(other.sectionType, sectionType) ||
                other.sectionType == sectionType) &&
            (identical(other.elementName, elementName) ||
                other.elementName == elementName) &&
            (identical(other.elementPosition, elementPosition) ||
                other.elementPosition == elementPosition) &&
            (identical(other.elementType, elementType) ||
                other.elementType == elementType) &&
            (identical(other.elementId, elementId) ||
                other.elementId == elementId) &&
            (identical(other.pageCode, pageCode) ||
                other.pageCode == pageCode) &&
            const DeepCollectionEquality().equals(other._meta, _meta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      sectionId,
      sectionName,
      sectionPosition,
      sectionType,
      elementName,
      elementPosition,
      elementType,
      elementId,
      pageCode,
      const DeepCollectionEquality().hash(_meta));

  /// Create a copy of SectionClickedEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SectionClickedEventImplCopyWith<_$SectionClickedEventImpl> get copyWith =>
      __$$SectionClickedEventImplCopyWithImpl<_$SectionClickedEventImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SectionClickedEventImplToJson(
      this,
    );
  }
}

abstract class _SectionClickedEvent implements SectionClickedEvent {
  const factory _SectionClickedEvent(
      {required final String sectionId,
      final String? sectionName,
      required final int sectionPosition,
      required final String sectionType,
      final String? elementName,
      required final int elementPosition,
      required final String elementType,
      required final String elementId,
      final String? pageCode,
      final Map<String, dynamic>? meta}) = _$SectionClickedEventImpl;

  factory _SectionClickedEvent.fromJson(Map<String, dynamic> json) =
      _$SectionClickedEventImpl.fromJson;

  @override
  String get sectionId;
  @override
  String? get sectionName;
  @override
  int get sectionPosition;
  @override
  String get sectionType;
  @override
  String? get elementName;
  @override
  int get elementPosition;
  @override
  String get elementType;
  @override
  String get elementId;
  @override
  String? get pageCode;
  @override
  Map<String, dynamic>? get meta;

  /// Create a copy of SectionClickedEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SectionClickedEventImplCopyWith<_$SectionClickedEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SectionAnalyticsData {
  String? get pageCode => throw _privateConstructorUsedError;
  String get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  int get position => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  Map<String, dynamic>? get meta => throw _privateConstructorUsedError;

  /// Create a copy of SectionAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SectionAnalyticsDataCopyWith<SectionAnalyticsData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SectionAnalyticsDataCopyWith<$Res> {
  factory $SectionAnalyticsDataCopyWith(SectionAnalyticsData value,
          $Res Function(SectionAnalyticsData) then) =
      _$SectionAnalyticsDataCopyWithImpl<$Res, SectionAnalyticsData>;
  @useResult
  $Res call(
      {String? pageCode,
      String id,
      String? name,
      int position,
      String type,
      Map<String, dynamic>? meta});
}

/// @nodoc
class _$SectionAnalyticsDataCopyWithImpl<$Res,
        $Val extends SectionAnalyticsData>
    implements $SectionAnalyticsDataCopyWith<$Res> {
  _$SectionAnalyticsDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SectionAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageCode = freezed,
    Object? id = null,
    Object? name = freezed,
    Object? position = null,
    Object? type = null,
    Object? meta = freezed,
  }) {
    return _then(_value.copyWith(
      pageCode: freezed == pageCode
          ? _value.pageCode
          : pageCode // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SectionAnalyticsDataImplCopyWith<$Res>
    implements $SectionAnalyticsDataCopyWith<$Res> {
  factory _$$SectionAnalyticsDataImplCopyWith(_$SectionAnalyticsDataImpl value,
          $Res Function(_$SectionAnalyticsDataImpl) then) =
      __$$SectionAnalyticsDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? pageCode,
      String id,
      String? name,
      int position,
      String type,
      Map<String, dynamic>? meta});
}

/// @nodoc
class __$$SectionAnalyticsDataImplCopyWithImpl<$Res>
    extends _$SectionAnalyticsDataCopyWithImpl<$Res, _$SectionAnalyticsDataImpl>
    implements _$$SectionAnalyticsDataImplCopyWith<$Res> {
  __$$SectionAnalyticsDataImplCopyWithImpl(_$SectionAnalyticsDataImpl _value,
      $Res Function(_$SectionAnalyticsDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of SectionAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pageCode = freezed,
    Object? id = null,
    Object? name = freezed,
    Object? position = null,
    Object? type = null,
    Object? meta = freezed,
  }) {
    return _then(_$SectionAnalyticsDataImpl(
      pageCode: freezed == pageCode
          ? _value.pageCode
          : pageCode // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      meta: freezed == meta
          ? _value._meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$SectionAnalyticsDataImpl implements _SectionAnalyticsData {
  const _$SectionAnalyticsDataImpl(
      {this.pageCode,
      required this.id,
      this.name,
      required this.position,
      required this.type,
      final Map<String, dynamic>? meta})
      : _meta = meta;

  @override
  final String? pageCode;
  @override
  final String id;
  @override
  final String? name;
  @override
  final int position;
  @override
  final String type;
  final Map<String, dynamic>? _meta;
  @override
  Map<String, dynamic>? get meta {
    final value = _meta;
    if (value == null) return null;
    if (_meta is EqualUnmodifiableMapView) return _meta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'SectionAnalyticsData(pageCode: $pageCode, id: $id, name: $name, position: $position, type: $type, meta: $meta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SectionAnalyticsDataImpl &&
            (identical(other.pageCode, pageCode) ||
                other.pageCode == pageCode) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._meta, _meta));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pageCode, id, name, position,
      type, const DeepCollectionEquality().hash(_meta));

  /// Create a copy of SectionAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SectionAnalyticsDataImplCopyWith<_$SectionAnalyticsDataImpl>
      get copyWith =>
          __$$SectionAnalyticsDataImplCopyWithImpl<_$SectionAnalyticsDataImpl>(
              this, _$identity);
}

abstract class _SectionAnalyticsData implements SectionAnalyticsData {
  const factory _SectionAnalyticsData(
      {final String? pageCode,
      required final String id,
      final String? name,
      required final int position,
      required final String type,
      final Map<String, dynamic>? meta}) = _$SectionAnalyticsDataImpl;

  @override
  String? get pageCode;
  @override
  String get id;
  @override
  String? get name;
  @override
  int get position;
  @override
  String get type;
  @override
  Map<String, dynamic>? get meta;

  /// Create a copy of SectionAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SectionAnalyticsDataImplCopyWith<_$SectionAnalyticsDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SectionItemAnalyticsData {
  int get position => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  Map<String, dynamic>? get meta => throw _privateConstructorUsedError;

  /// Create a copy of SectionItemAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SectionItemAnalyticsDataCopyWith<SectionItemAnalyticsData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SectionItemAnalyticsDataCopyWith<$Res> {
  factory $SectionItemAnalyticsDataCopyWith(SectionItemAnalyticsData value,
          $Res Function(SectionItemAnalyticsData) then) =
      _$SectionItemAnalyticsDataCopyWithImpl<$Res, SectionItemAnalyticsData>;
  @useResult
  $Res call(
      {int position,
      String type,
      String id,
      String? name,
      Map<String, dynamic>? meta});
}

/// @nodoc
class _$SectionItemAnalyticsDataCopyWithImpl<$Res,
        $Val extends SectionItemAnalyticsData>
    implements $SectionItemAnalyticsDataCopyWith<$Res> {
  _$SectionItemAnalyticsDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SectionItemAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? position = null,
    Object? type = null,
    Object? id = null,
    Object? name = freezed,
    Object? meta = freezed,
  }) {
    return _then(_value.copyWith(
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SectionItemAnalyticsDataImplCopyWith<$Res>
    implements $SectionItemAnalyticsDataCopyWith<$Res> {
  factory _$$SectionItemAnalyticsDataImplCopyWith(
          _$SectionItemAnalyticsDataImpl value,
          $Res Function(_$SectionItemAnalyticsDataImpl) then) =
      __$$SectionItemAnalyticsDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int position,
      String type,
      String id,
      String? name,
      Map<String, dynamic>? meta});
}

/// @nodoc
class __$$SectionItemAnalyticsDataImplCopyWithImpl<$Res>
    extends _$SectionItemAnalyticsDataCopyWithImpl<$Res,
        _$SectionItemAnalyticsDataImpl>
    implements _$$SectionItemAnalyticsDataImplCopyWith<$Res> {
  __$$SectionItemAnalyticsDataImplCopyWithImpl(
      _$SectionItemAnalyticsDataImpl _value,
      $Res Function(_$SectionItemAnalyticsDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of SectionItemAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? position = null,
    Object? type = null,
    Object? id = null,
    Object? name = freezed,
    Object? meta = freezed,
  }) {
    return _then(_$SectionItemAnalyticsDataImpl(
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      meta: freezed == meta
          ? _value._meta
          : meta // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc

class _$SectionItemAnalyticsDataImpl implements _SectionItemAnalyticsData {
  const _$SectionItemAnalyticsDataImpl(
      {required this.position,
      required this.type,
      required this.id,
      this.name,
      final Map<String, dynamic>? meta})
      : _meta = meta;

  @override
  final int position;
  @override
  final String type;
  @override
  final String id;
  @override
  final String? name;
  final Map<String, dynamic>? _meta;
  @override
  Map<String, dynamic>? get meta {
    final value = _meta;
    if (value == null) return null;
    if (_meta is EqualUnmodifiableMapView) return _meta;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'SectionItemAnalyticsData(position: $position, type: $type, id: $id, name: $name, meta: $meta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SectionItemAnalyticsDataImpl &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._meta, _meta));
  }

  @override
  int get hashCode => Object.hash(runtimeType, position, type, id, name,
      const DeepCollectionEquality().hash(_meta));

  /// Create a copy of SectionItemAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SectionItemAnalyticsDataImplCopyWith<_$SectionItemAnalyticsDataImpl>
      get copyWith => __$$SectionItemAnalyticsDataImplCopyWithImpl<
          _$SectionItemAnalyticsDataImpl>(this, _$identity);
}

abstract class _SectionItemAnalyticsData implements SectionItemAnalyticsData {
  const factory _SectionItemAnalyticsData(
      {required final int position,
      required final String type,
      required final String id,
      final String? name,
      final Map<String, dynamic>? meta}) = _$SectionItemAnalyticsDataImpl;

  @override
  int get position;
  @override
  String get type;
  @override
  String get id;
  @override
  String? get name;
  @override
  Map<String, dynamic>? get meta;

  /// Create a copy of SectionItemAnalyticsData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SectionItemAnalyticsDataImplCopyWith<_$SectionItemAnalyticsDataImpl>
      get copyWith => throw _privateConstructorUsedError;
}
